#' Shiny Module UI for Dendro Plot
#'
#' @param id identifier for shiny reactive
#'
#' @return nothing returned
#' @rdname shinyModuleDatasets
#' @export
#'
shinyModuleDatasetsUI <- function(id) {
  ns <- NS(id)
  shiny::uiOutput(ns("shiny_moddata"))
}

#' Shiny Module Server for Dendro Plots
#'
#' @param input,output,session standard shiny arguments
#' @param module_par,main_par reactive arguments from `foundrServer` and `shinyModules`
#' @param traitModule reactive object with list created by `listof_wgcnamodules`
#'
#' @return reactive object for `shinyModuleDatasetsUI`
#' @importFrom shiny plotOutput reactive renderPlot renderUI req
#'             tagList uiOutput
#' @importFrom DT renderDataTable
#' @export
#'
shinyModuleDatasets <- function(input, output, session,
                        module_par, main_par, traitModule) {
  ns <- session$ns
  
  # INPUTS
  # foundrServer inputs: (see shinyapp.R)
  #   main_par$height (see shinyapp.R::foundrUI sidebarPanel)
  # shinyModules inputs: (see shinyModules.R)
  #   module_par$dataset
  #   module_par$response
  #   module_par$responseF Facet Response
  #   module_par$responseC Color Response
  # shinyModuleDatasets inputs: (see output$shiny_modcomp below)
  #   input$fmodules  Facet Modules
  #   input$cmodules  Color Modules

  output$shiny_moddata <- shiny::renderUI({
    shiny::tagList(
      shiny::fluidRow(
        shiny::column(
          6,
          shiny::selectInput(
            "datasetD", "Facet Dataset:",
            datasets)),
        shiny::column(
          6,
          shiny::selectInput(
            "dataset2", "Color Dataset:",
            datasets)) # *** Want this to be datasets with same traits ***.
      ),
      
      shiny::fluidRow(
        shiny::column(
          4,
          shiny::selectInput(
            "fmodules2", "Facet Modules:",
            c("gray","turquoise"),
            multiple = TRUE)),
        shiny::column(
          4,
          shiny::selectInput(
            "cmodules2", "Color Modules:",
            c("gray","turquoise"),
            multiple = TRUE)),
        shiny::column(
          2,
          checkboxInput("absD", "Absolute kME?"))
      ),
      
      shiny::uiOutput(ns("moddatasets"))
    )
  })
  
  output$moddatasets <- shiny::renderUI({
    shiny::tagList(
      shiny::renderUI(ns("plotly")),
      shiny::renderUI(ns("eigenplotly")),
      shiny::renderUI(ns("pointkey")),
      shiny::renderUI(ns("pairplot")),
      shiny::renderUI(ns("pairtable"))
    )
  })
  
  responseD <- reactive({ "value" })
  
  dataset2 <- shiny::reactive({
    shiny::req(input$datasetD)
    datasets[input$datasetD != datasets][1]
  })
  
  fmodules2 <- shiny::reactive({
    shiny::req(metmods(), input$datasetD)
    levels(metmods()[[paste0(input$datasetD, "_col")]])
  })
  
  cmodules2 <- shiny::reactive({
    shiny::req(metmods(), input$dataset2)
    levels(metmods()[[paste0(input$dataset2, "_col")]])
  })
  
  shiny::observeEvent(
    input$datasetD,
    {
      shiny::updateSelectInput(
        session, "fmodules2",
        choices = fmodules2(),
        selected = fmodules2())
    })
  
  shiny::observeEvent(
    input$dataset2,
    {
      shiny::updateSelectInput(
        session, "cmodules2",
        choices = cmodules2(),
        selected = cmodules2())
    })
  
  dmods <- shiny::reactive({
    shiny::req(input$datasetD, input$dataset2, input$responseD)
    
    foundr::join_dataset_modules(
      traitModule[c(input$datasetD, input$dataset2)],
      input$responseD)
  })
  
  metmods <- shiny::reactive({
    shiny::req(dmods())
    foundr::module_kMEs(dmods())
  })
  
  moddata2 <- shiny::reactive({
    shiny::req(metmods(), input$datasetD, input$dataset2,
               input$fmodules2, input$cmodules2)
    
    foundr::subset_module_kMEs(
      metmods(), input$datasetD, input$dataset2,
      facetmodules = input$fmodules2,
      colormodules = input$cmodules2)
  })
  
  # Plot of Modules comparing datasets.
  modplot <- shiny::reactive({
    ggplot2::autoplot(
      moddata2(),
      input$datasetD, input$dataset2, input$absD)
  })
  
  output$plotly <- plotly::renderPlotly({
    shiny::req(moddata2(), input$datasetD, input$dataset2)
    if(is.null(moddata2()))
      foundr::plot_null("no moddata2 data")
    else {
      plotly::event_register(
        plotly::ggplotly(modplot()),
        "plotly_click")
    }
  })
  
  # Eigen Plot.
  eigenMet <- shiny::reactive({
    shiny::req(dmods())
    foundr::eigen_cor(dmods())
  })
  
  output$eigenplotly <- plotly::renderPlotly({
    shiny::req(eigenMet(), input$dataset2, input$datasetD)
    print(
      ggplot2::autoplot(
        eigenMet(),
        input$datasetD, input$dataset2))
  })
  
  # Plot and tables generated by pointKey.
  pointKey <- reactive({
    shiny::req(moddata2())
    point <- plotly::event_data(
      event = "plotly_click", priority = "event")
    shiny::req(point) # to avoid error if no point is clicked
    point$key
  })
  
  output$pointkey <- shiny::renderTable({
    shiny::req(moddata2(), pointKey())
    dplyr::filter(
      moddata2(),
      trait == pointKey()) # use the key to find selected point
  })
  
  pairData <- shiny::reactive({
    shiny::req(pointKey())
    foundr::traitSolos(
      dplyr::filter(
        traitData,
        trait == pointKey()),
      dplyr::filter(
        traitSignal,
        trait == pointKey()))
  })
  
  output$pairplot <- shiny::renderPlot({
    shiny::req(pairData())
    foundr::ggplot_traitPairs(
      foundr::traitPairs(pairData()))
  })
  
  output$pairtable <- DT::renderDataTable({
    shiny::req(pairData(), pointKey())
    DT::datatable(
      pairData(),
      options = list(paging =TRUE, pageLength = 5))
  })

  ###############################################
  # List returned
  reactive({
    shiny::req(module_par$dataset, module_par$responseF, module_par$responseC,
               modcompplot(), modcomptable())
    list(
      plot = print(modplot()),
      table = pairData(),
      traits = c(module_par$dataset, module_par$responseF, module_par$responseC))
  })
}
